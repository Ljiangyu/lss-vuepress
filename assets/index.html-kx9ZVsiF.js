import{_ as t,c as r,d as i,a as l,o as n,r as s}from"./app-Cjt4Wlb7.js";const o={};function c(m,a){const e=s("comment");return n(),r("div",null,[a[0]||(a[0]=i('<blockquote><p>使用mysql存储日期时间时，varchar和datetime</p></blockquote><h2 id="存储日期" tabindex="-1"><a class="header-anchor" href="#存储日期"><span>存储日期</span></a></h2><p>在mysql中，存储日期时，varchar和datetime都可以使用。</p><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h2><ol><li>varchar需要手动设置长度，而datetime不需要。</li><li>varchar可以存储自定义格式的日期，而datetime只能存储固定格式的日期。</li><li>varchar可以存储更长的日期，而datetime只能存储到秒级。</li><li>varchar存储没有时区信息，而datetime存储时区信息。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>前两天开发中，看到使用varchar存储日期，就有点疑惑，和同事聊了一下，前端传日期时间类型的数据，后端接受可能会有一些数据上的问题</p><ul><li>日期时间类型json序列化后，传递的类型，可能与后端期望的类型不一致 <ul><li>如果前端直接发送原生的 JavaScript Date 对象，它在序列化为 JSON 时通常会转换成 ISO 8601 格式的字符串（例如 &quot;2024-12-14T19:16:00Z&quot;）。这种格式在大多数情况下是安全且可靠的，但如果后端期望的是另一种格式，则可能导致解析错误。</li></ul></li></ul>',8)),l(e)])}const h=t(o,[["render",c],["__file","index.html.vue"]]),u=JSON.parse('{"path":"/article/luqn835b/","title":"存储日期varchar、datetime","lang":"zh-CN","frontmatter":{"title":"存储日期varchar、datetime","createTime":"2024/12/14 19:13:03","permalink":"/article/luqn835b/","tags":["mysql","mysql数值类型"]},"headers":[],"readingTime":{"minutes":1.03,"words":309},"git":{"updatedTime":1734796031000,"contributors":[{"name":"Ljiangyu","email":"104154611+Ljiangyu@users.noreply.github.com","commits":3,"avatar":"https://avatars.githubusercontent.com/Ljiangyu?v=4","url":"https://github.com/Ljiangyu"}]},"filePathRelative":"database/mysql/存储日期varchar、datetime.md","categoryList":[{"id":"11e0ee","sort":10003,"name":"database"},{"id":"844122","sort":10004,"name":"mysql"}],"bulletin":false}');export{h as comp,u as data};
